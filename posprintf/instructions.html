<HTML><HEAD><TITLE>posprintf Documentation</TITLE></HEAD><BODY><H1><CENTER>posprintf Documentation</CENTER></H1><P><H2>What is it?</H2><P><CODE>posprintf</CODE> is a function you can call in your Gameboy Advance programs to generate strings. It is basically a somewhat amputated version of the standard C library function, <CODE>sprintf</CODE>.<P><HR><P><H2>Why use it?</H2><P>Probably the most significant use of it is to print out and format numbers for display on the screen. In order to do this, the numbers need to be converted from their internal representation (base 2) to decimal (base 10). <CODE>posprintf</CODE> uses an <A HREF = "http://www.cs.uiowa.edu/~jones/bcd/decimal.html">extremely efficient algorithm scammed off of the 'net</A> to do this, and it is written entirely in Thumb assembler to run very quickly (without consuming the internal memory needed to run efficiently in ARM mode).<P>Other reasons to use it include that it's fast, extremely flexible for most GBA applications, and absolutely free. <A HREF = "#credit">I wouldn't say no to a credit</A> if it is used in an application, though, commercial or otherwise.<P><HR><P><H2>How do I use it?</H2><P><OL><LI>Include the file <CODE>posprintf.h</CODE> in your C source code that you want to call the function. (ie. <CODE>#include "posprintf.h"</CODE>)<P><LI>Call it the same way you would call <CODE>sprintf</CODE>, keeping in mind the differences between the two (see the next section).<P><LI>Make sure to link the file <CODE>posprintf.o</CODE> with your project. Generally this just means including <CODE>posprintf.o</CODE> on the command line when you call gcc.</OL><P>That's all there is to it.<P><HR><P><H2>How do I call the function?</H2><P>The syntax is as follows:<P><BLOCKQUOTE><CODE>posprintf(char *<I>dest</I>, const char *<I>src</I>[, <I>param1</I>[, <I>param2</I>[, ... <I>paramN</I>]]]);</CODE></BLOCKQUOTE><P><UL><LI><CODE><I>dest</I></CODE> is the address of the string to be printed out to. <B>IMPORTANT:</B> There must be sufficient memory allocated to the buffer to hold the string, including the terminating zero.<P><LI><CODE><I>src</I></CODE> is the address of the source string to print. This absolutely <B>must</B> be a valid, zero-terminated C string.<P><LI>The optional parameters accompany any format specifiers used in the source string.</UL><P><H3>Format Specifiers</H3><P>The following are valid format specifiers for use with <CODE>posprintf</CODE>:<P><UL><LI><CODE>%%</CODE> - print a <CODE>%</CODE> character<LI><CODE>%s</CODE> - print a string. The accompanying parameter must be a valid, zero-terminated C string.<LI><CODE>%d</CODE> - print an integer. <B>Important</B>: unlike <CODE>sprintf</CODE>, this is only accurate for 16 bits of data, or numbers ranging from -65,535 to 65,535.<LI><CODE>%l</CODE> - print a long integer. <B>Important</B>: unlike <CODE>sprintf</CODE> this is only accurate for approximately 29 bits of data, or numbers ranging from about -500 million to 500 million.<LI><CODE>%x</CODE> - print in hexadecimal format. Provided mostly as a programming tool, since few user applications would probably ever want to print hexadecimal numbers.<LI><CODE>%X</CODE> - same as <CODE>%x</CODE>, but prints capital letters for the digits 'a' through 'f'.</UL><P><H3>Output Control</H3><P>The output of <CODE>%d</CODE>, <CODE>%l</CODE>, <CODE>%x</CODE> and <CODE>%X</CODE> tags may optionally be influenced by the following prefixes:<P><UL><LI><B>Digits 1 through 9</B>: Indicate how many leading spaces to include. Examples:<P><UL><LI><CODE>%5d</CODE> would print the number 123 as <CODE>"  123"</CODE><LI><CODE>%3d</CODE> would print the number 12345 as <CODE>"12345"</CODE> (no leading spaces)</UL><P><LI><B>Digit 0</B>: When prefixing the above number, indicates to print leading zeros instead of leading spaces. Examples:<P><UL><LI><CODE>%05d</CODE> would print the number 123 as <CODE>"00123"</CODE><LI><CODE>%03d</CODE> would print the number 12345 as <CODE>"12345"</CODE> (no leading zeros)</UL></UL><P><B>Note</B>: If the number printed is negative, then the negative sign will consume a leading space/zero, if there are any.<P><HR><P><H2>Other Notes</H2><P><H3>Optimized for GBA development</H3><P>One of the big realizations in understanding this code is that few GBA games need to display numbers larger than 65,535, and when they do these are the minority of numbers, not the majority. The <CODE>%d</CODE> specifier is highly optimized to work with 16 bits, and you should use it whenever possible.<P>For the minority of occasions when you need to display more than 16 bits worth of numerical data, <CODE>%l</CODE> works fine to numbers well beyond the plus-or-minus 500 million mark. (The actual limit is +/- 655,359,999.) It takes about twice as long to run as <CODE>%d</CODE>, though, and includes a slow SWI call to split the number into two chunks, so you should still use <CODE>%d</CODE> instead whenever you can.<P>If you need to display numbers larger than 500 million, then you will either have to heavily alter the code, use a different utility, or break your number up into sizeable chunks. If you do need to display larger numbers than 500 million for a GBA game, though, you may want to rethink your game design.<P><H3>What about other ARM machines?</H3><P>Although <CODE>posprintf</CODE> is mostly written as generic Thumb code, the %l (29-bit print) specifier code currently uses a software interrupt (SWI) specific to the Gameboy Advance to perform a division. If you wish to port this to other ARM machines, you may need to alter this code. I believe that most ARM machines support SWI 7 as an alternative software divide, although you will have to swap the numerator/denominator registers (r0 and r1).<P><H3>Can't you optimize out the SWI call? Use inverse multiplication, register shifting, or somesuch?</H3><P>Not easily. Not in Thumb mode, anyway, which doesn't have the 64-bit multiply instruction. The number has many significant digits, and is being divided by 10,000, which requires two registers to keep things accurate. My best advice is to avoid it in the first place by keeping your numbers small and using <CODE>%d</CODE> instead, but also not to fret over using <CODE>%l</CODE> as the SWI is only issued once in the entire routine, and everything else is still quite zippy. It is not like you will have to call it a bazillion times per frame, and it's still a helluva lot faster than what the standard library <CODE>sprintf</CODE> does. If anyone does feel like optimizing this, though, please <A HREF = "#credit">send me the results</A>.<P><H3>If it's displaying 16-bit numbers and they are signed, shouldn't they only be in the range +/- 32767?</H3><P>The conversion to base 10 is actually done on the number unsigned, so you get a full range up to 65,535. The sign is taken from the extension of the number to 32 bits, which happens automatically regardless of whether you pass a short or not. The same applies to <CODE>%l</CODE>.<P><H3>What are the terms and restrictions to using posprintf?</H3><P><CODE>posprintf</CODE> is part of the <A HREF="http://creativecommons.org/licenses/publicdomain/">public domain</A>, with no licenses attached.<P><H3>Why "posprintf"?</H3><P>I think the "po" stood for something originally, but now the "pos" is just a play on my last name. Please, no P.O.S. jokes. :)<P><HR><P><A NAME = "credit"><H1>Contacting the Author</H1><P>Please submit all bug reports, queries, suggested improvements, etc. to Dan Posluns at <A HREF = "mailto:dan@danposluns.com">dan@danposluns.com</A>.<P><HR><P><CENTER><B>F I N</B></CENTER></BODY></HTML>